<!DOCTYPE html>
<html lang="en">
<head>
  <script type="module">import { injectIntoGlobalHook } from "/@react-refresh"
injectIntoGlobalHook(window);
window.$RefreshReg$ = () => {};
window.$RefreshSig$ = () => (type) => type;</script>

  <script type="module" src="/@vite/client"></script>

  <meta charset="UTF-8">
  <title>Manual Postback Firing Tool</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2em; }
    label { display: block; margin-top: 1em; }
    textarea { width: 100%; height: 120px; }
    input[type="text"] { width: 200px; }
    .url-list { margin-top: 1em; }
    .url-item { font-size: 0.95em; margin-bottom: 3px; }
    .success { color: green; }
    .fail { color: red; }
    .processing { color: orange; }
    .radio-group { display: flex; gap: 1em; margin-top: 0.5em; }
    .radio-group div { display: flex; align-items: center; gap: 0.5em; }
  </style>
</head>
<body>
  <h2>Manual Postback Firing Tool</h2>
  <form id="mainForm" onsubmit="return false;">
    <label>mbm: <input type="text" id="mbm" required></label>
    <label>mbr (optional): <input type="text" id="mbr"></label>

    <label style="margin-top: 1em;">Select Parameter Type:</label>
    <div class="radio-group">
      <div>
        <input type="radio" id="paramTypeMbcm" name="paramType" value="mbcm" checked>
        <label for="paramTypeMbcm" style="margin-top: 0;">mbcm</label>
      </div>
      <div>
        <input type="radio" id="paramTypeMbs" name="paramType" value="mbs">
        <label for="paramTypeMbs" style="margin-top: 0;">mbs</label>
      </div>
    </div>

    <label style="margin-top: 1em;">
      Paste tab-delimited (<span id="paramTypeLabel">mbcm</span> &mdash; mbd &mdash; mbi) rows:
      <textarea id="inputRows" placeholder="E.g.&#10;130	9560.6420.88857	186118092"></textarea>
    </label>
    <button type="button" onclick="generateUrls()">Generate URLs</button>
    <button type="button" onclick="processUrls()">Process</button>
  </form>
  <div id="urlList" class="url-list"></div>
  <script>
    let urls = [];
    let isProcessing = false;

    document.querySelectorAll('input[name="paramType"]').forEach(radio => {
      radio.addEventListener('change', (event) => {
        document.getElementById('paramTypeLabel').textContent = event.target.value;
      });
    });

    function getSelectedParamType() {
      return document.querySelector('input[name="paramType"]:checked').value;
    }

    function generateUrls() {
      urls = [];
      document.getElementById('urlList').innerHTML = '';
      const mbm = document.getElementById('mbm').value.trim();
      const mbr = document.getElementById('mbr').value.trim();
      const inputRows = document.getElementById('inputRows').value.trim();
      const paramType = getSelectedParamType();

      if (!mbm) {
        alert('mbm is required.');
        return;
      }

      const rows = inputRows.split('\n');

      rows.forEach((row, idx) => {
        const cols = row.split('\t');
        if (cols.length !== 3) return;

        const param1 = encodeURIComponent(cols[0].trim()); // This will be mbcm or mbs
        const mbd = encodeURIComponent(cols[1].trim());
        const mbi = encodeURIComponent(cols[2].trim());

        let baseUrl = `https://chant3rm1.com/trk/lead?mbm=${encodeURIComponent(mbm)}`;
        if (mbr) { // Only add mbr if it's not empty
          baseUrl += `&mbr=${encodeURIComponent(mbr)}`;
        }
        
        const url = `${baseUrl}&${paramType}=${param1}&mbd=${mbd}&mbi=${mbi}`;
        urls.push({ id: `url-${idx}`, url, status: "pending", message: "" });
      });

      if (urls.length === 0) {
        document.getElementById('urlList').innerHTML = '<div class="url-item fail">No valid rows found. Please ensure rows are tab-delimited with 3 columns.</div>';
      } else {
        renderUrls();
      }
    }

    function renderUrls() {
      const urlListDiv = document.getElementById('urlList');
      urlListDiv.innerHTML = urls.map(item => {
        let statusClass = '';
        if (item.status === 'success') statusClass = 'success';
        else if (item.status === 'fail') statusClass = 'fail';
        else if (item.status === 'processing') statusClass = 'processing';

        return `<div class="url-item ${statusClass}" id="${item.id}">${item.url} ${item.message}</div>`;
      }).join('');
    }

    async function processUrls() {
      if (urls.length === 0) {
        alert('Generate URLs first.');
        return;
      }
      if (isProcessing) return;

      isProcessing = true;
      // Update all URLs to pending status initially
      urls = urls.map(item => ({ ...item, status: "pending", message: "" }));
      renderUrls();

      const CONCURRENCY_LIMIT = 5; // Number of concurrent requests
      const tasks = urls.map((urlItem) => async () => {
        // Mark as processing
        urls = urls.map(u => u.id === urlItem.id ? { ...u, status: "processing", message: "... Processing" } : u);
        renderUrls();

        let result;
        try {
          const response = await fetch(urlItem.url);
          if (response.ok) {
            result = { status: "success", message: "✔ Success" };
          } else {
            result = { status: "fail", message: `✖ Failed (${response.status})` };
          }
        } catch (e) {
          result = { status: "fail", message: "✖ Error" };
        }

        // Update with final result
        urls = urls.map(u => (u.id === urlItem.id ? { ...u, ...result } : u));
        renderUrls();
      });

      const runningPromises = [];
      let taskIndex = 0;

      const runNextTask = () => {
        if (taskIndex < tasks.length) {
          const task = tasks[taskIndex];
          taskIndex++;
          const promise = task().finally(() => {
            // Remove the finished promise from the running pool
            const index = runningPromises.indexOf(promise);
            if (index > -1) {
              runningPromises.splice(index, 1);
            }
            // Run the next task if available
            runNextTask();
          });
          runningPromises.push(promise);
        }
      };

      // Start initial concurrent tasks up to the concurrency limit
      for (let i = 0; i < CONCURRENCY_LIMIT && i < tasks.length; i++) {
        runNextTask();
      }

      // Wait for all running promises to complete
      await Promise.all(runningPromises);

      isProcessing = false;
      alert("All URLs processed!");
    }
  </script>
</body>
</html>
